package com.example.cache.ui.home

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageButton
import android.widget.PopupMenu
import android.widget.TextView
import androidx.databinding.DataBindingUtil
import androidx.lifecycle.Observer
import androidx.lifecycle.ViewModelProvider
import androidx.navigation.fragment.findNavController
import androidx.recyclerview.widget.DividerItemDecoration
import com.example.cache.R
import com.example.cache.data.repository.AccountRepository.Companion.totals
import com.example.cache.databinding.FragmentHomeBinding
import com.example.cache.ui.adapters.AccountsAdapter
import dagger.android.support.DaggerFragment
import javax.inject.Inject


class HomeFragment : DaggerFragment() {

    @Inject
    lateinit var viewModelFactory: ViewModelProvider.Factory

    /**
     * Called when the Fragment is ready to display content to the screen.
     *
     * This function uses DataBindingUtil to inflate R.layout.fragment_sleep_quality.
     * *
     * It is also responsible for passing the [HomeViewModel] to the
     * [FragmentHomeBinding] generated by DataBinding. This will allow DataBinding
     * to use the [LiveData] on our ViewModel.
     */
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
                              savedInstanceState: Bundle?): View? {

        // Get a reference to the binding object and inflate the fragment views.
        val binding: FragmentHomeBinding = DataBindingUtil.inflate(
            inflater, R.layout.fragment_home, container, false)

        // Get a reference to the ViewModel associated with this fragment
        val homeViewModel = ViewModelProvider(this, viewModelFactory).get(HomeViewModel::class.java)

        // To use the View Model with data binding, you have to explicitly
        // give the binding object a reference to it.
        binding.homeViewModel = homeViewModel

        // Specify the current activity as the lifecycle owner of the binding.
        // This is necessary so that the binding can observe LiveData updates.
        binding.lifecycleOwner = this

        val homeGreetingTextView: TextView = binding.root.findViewById(R.id.home_greeting)
        homeGreetingTextView.text = homeViewModel.getGreetingMessage()

        val accountsOverviewAdapter = AccountsAdapter()
        binding.accountsOverviewView.adapter = accountsOverviewAdapter

        homeViewModel.accounts.observe(viewLifecycleOwner, Observer { accounts ->
            accounts?.let {
                accountsOverviewAdapter.data = accounts
                accountsOverviewAdapter.subData = accounts.totals()
            }
        })

        val divider = DividerItemDecoration(this.context, DividerItemDecoration.VERTICAL)
        binding.accountsOverviewView.addItemDecoration(divider)

        val settingsButton = binding.root.findViewById<ImageButton>(R.id.button_settings)
        settingsButton.setOnClickListener { view ->
            val popup = PopupMenu(view.context, settingsButton)
            popup.setOnMenuItemClickListener { item ->
                when (item.itemId) {
                    R.id.menu_stocks -> {
                        findNavController().navigate(R.id.navigation_investment)
                    }
                }
                true
            }

            popup.menuInflater.inflate(R.menu.home_menu, popup.menu)
            popup.show()
        }

        return binding.root
    }
}
